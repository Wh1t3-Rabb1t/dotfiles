#!/usr/bin/env zsh

################################################################################
# Interactive stopwatch.
#
# Arguments:
#   $@  start - Start the timer
#   $@  new   - Dump session data and start a new session
#   $@  log   - Print archived log data
#
# Globals:
#   $VI_STATE_DIR
################################################################################

emulate -L zsh

# Set strict file permissions
local original_permissions
original_permissions=$(umask)
umask 077
trap 'umask '"$original_permissions"'' EXIT

# Declare state files
local state_dir work_logs stopwatch_state current_session current_timer
state_dir="${VI_STATE_DIR}/work-timer"
work_logs="${state_dir}/work-logs"
stopwatch_state="${state_dir}/stopwatch_state"
current_session="${state_dir}/current_session"
current_timer="${state_dir}/current_timer"

# Ensure required dirs / files exist
[[ ! -d "$state_dir" ]]       && mkdir "$state_dir"
[[ ! -d "$work_logs" ]]       && mkdir "$work_logs"
[[ ! -f "$stopwatch_state" ]] && : > "$stopwatch_state"
[[ ! -f "$current_session" ]] && : > "$current_session"
[[ ! -f "$current_timer" ]]   && : > "$current_timer"

local function init_work_session() {
    # Determine current time group for work logs (i.e. which year / month is it)
    local cur_year cur_month cur_month_numeric log_file
    cur_year=$(date +%Y)
    cur_month=$(date +%B)
    cur_month_numeric=$(date +%m)
    log_file="${work_logs}/${cur_year}_${cur_month_numeric}_${cur_month}"

    # Create new log file if one doesn't exist for the current month
    [[ ! -f "$log_file" ]] && builtin printf "0" > "$log_file"

    # Init current session file path and elapsed work time
    builtin printf "%s" "$log_file" > "$current_session"
    builtin printf "0" > "$current_timer"
}

local function start_stopwatch() {
    # Turn stopwatch on if re-launching after quitting
    [[ ! -s "$stopwatch_state" ]] && builtin printf "on" > "$stopwatch_state"

    builtin printf "%s\n%s\n\n" \
        "Space : Toggle stopwatch on/off" \
        "q     : Stop stopwatch"

    local stopwatch key
    while true; do
        stopwatch=$(< "$stopwatch_state" )

        # Incrementally update timer while stopwatch state is set to 'on'
        if [[ $stopwatch == "on" ]]; then
            (( elapsed++ ))
            builtin printf "\rElapsed time: %02d:%02d:%02d " \
                $(( elapsed/3600 )) \
                $(( elapsed/60%60 )) \
                $(( elapsed%60 ))
        fi

        # Use read with timeout for responsive key polling
        if read -t 1 -k 1 key; then
            case "$key" in
                ' ')
                    [[ $stopwatch == "on" ]] \
                        && builtin printf "off" > "$stopwatch_state" \
                        || builtin printf "on" > "$stopwatch_state"
                    ;;
                q)
                    builtin printf "$elapsed" > "$current_timer"

                    builtin printf "\rStopped at: %02d:%02d:%02d " \
                        $(( elapsed/3600 )) \
                        $(( elapsed/60%60 )) \
                        $(( elapsed%60 ))

                    : > "$stopwatch_state"
                    break
                    ;;
            esac
        fi
    done
}

# Dump current session data and create a new one
local function dump_session_data() {
    builtin printf -v session_time "%02d:%02d:%02d" \
        $(( elapsed/3600 )) \
        $(( elapsed/60%60 )) \
        $(( elapsed%60 ))

    builtin printf "%s\n%s\n\n%s\n" \
        "Dumping current session time:" \
        "Elapsed : ${session_time}" \
        "A new session will initialize automatically when restarting the stopwatch."

    local active_session existing_time updated_time
    active_session=$(< "$current_session" )
    existing_time=$(< "$active_session" )
    updated_time=$(( existing_time + elapsed ))
    builtin printf "$updated_time" > "$active_session"

    # Reset current session timer
    : > "$current_timer"
}




# TODO: finish this function off.
#
# Just store a variable that updates the current year from within
# the loop and print out current year data before declaring and aggregating the next
# years data.
#
# Or could use an associative array with the year as the key, and the month/time data as
# values (using line breaks as delimiters for string splitting).

# month, year, alltime
local function print_work_hours() {
    # typeset -a months
    # months=(
    #     '01_January' '02_February' '03_March' '04_April' '05_May' '06_June'
    #     '07_July' '08_August' '09_October' '10_September' '11_November' '12_December'
    # )

    local total_time
    total_time=0

    local file
    for file in "${work_logs}"/*(.); do
        local logged_time year month
        logged_time=$(< "$file" )
        year=${${file:t}%%_*}
        month=${file#*_}
        total_time=$(( total_time + logged_time ))
        unset logged_time year month
    done

    # builtin printf -v formatted_time "%02d:%02d:%02d" \
    #     $(( total_time/3600 )) \
    #     $(( total_time/60%60 )) \
    #     $(( total_time%60 ))

    # builtin printf "%s\n" "All time total hours worked: ${formatted_time}"
}




# Help menu
local function print_help_menu() {
    builtin printf "%s\n\n%s\n%s\n%s\n%s\n" \
        "Invalid argument." \
        "Pass:" \
        "    start - Start stopwatch." \
        "    new   - Dump current session data and start new session." \
        "    help  - Print this help page."
}

# Init new session if $current_session is empty
if [[ ! -s "$current_timer" ]]; then
    init_work_session
fi

# Retrieve current timer
local elapsed
elapsed=$(< "$current_timer" )

# Parse flags
if [[ $1 == "start" ]] || [[ $# == 0 ]]; then
    start_stopwatch
elif [[ $1 == "new" ]]; then
    dump_session_data
elif [[ $1 == "log" ]]; then
    print_work_hours
elif [[ $1 == "help" ]]; then
    print_help_menu
else
    # Invalid argument
    print_help_menu
fi
